<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover (fixed)</title>
  <style>
    body { font-family: Arial, sans-serif; background:#0d0d0d; color:#fff; margin:0; padding:20px; text-align:center; }
    .container { max-width:900px; margin:auto; }
    #uploadBox { border:2px dashed #555; padding:36px; border-radius:12px; margin-bottom:16px; cursor:pointer; background:#111; }
    #uploadBox:hover { border-color:#00eaff; }
    .tools { margin-top:8px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:center; }
    .btn { background:#00eaff; border:none; padding:10px 16px; color:#000; border-radius:8px; font-size:14px; cursor:pointer; }
    .btn.ghost { background:#333; color:#fff; }
    input[type=range] { width:160px; }
    #canvasWrapper { display:flex; gap:16px; margin-top:16px; justify-content:space-between; }
    #canvasWrapper > div { flex:1; min-width:0; }
    canvas { background:#222; width:100%; border-radius:10px; display:block; }
    p { margin:8px 0; }
    #downloadBtn { margin-top:8px; display:inline-block; }
    /* small responsive fix */
    @media(max-width:780px){ #canvasWrapper{ flex-direction:column } .tools{ gap:6px } }
  </style>
</head>
<body>
  <div class="container">
    <h1>Background Remover</h1>

    <div id="uploadBox">Tap to Upload Image</div>
    <input type="file" id="fileInput" accept="image/*" hidden />

    <div class="tools">
      <button class="btn" id="brushMode">Enable Brush</button>
      <button class="btn ghost" id="eraseMode">Erase Mode</button>
      <button class="btn" id="undoBtn">Undo</button>
      <button class="btn" id="redoBtn">Redo</button>
      <button class="btn" id="smartBtn">Smart Object Select</button>
      <button class="btn" id="processBtn">Remove Background</button>
      <label style="color:#bbb">Brush:</label>
      <input type="range" min="5" max="80" value="20" id="brushSize">
      <label style="color:#bbb">Soft:</label>
      <input type="range" min="0" max="1" step="0.05" value="0.35" id="brushSoftness">
      <select id="exportFmt" style="padding:8px;border-radius:8px;background:#333;color:#fff">
        <option value="png">PNG (transparent)</option>
        <option value="jpg">JPG</option>
        <option value="webp">WEBP</option>
      </select>
    </div>

    <div id="canvasWrapper">
      <div>
        <p>Before</p>
        <canvas id="beforeCanvas"></canvas>
      </div>
      <div>
        <p>After</p>
        <canvas id="afterCanvas"></canvas>
        <br>
        <button class="btn" id="downloadBtn">Download</button>
      </div>
    </div>
  </div>

<script>
/* ========= Elements ========= */
const uploadBox = document.getElementById('uploadBox');
const fileInput = document.getElementById('fileInput');
const beforeCanvas = document.getElementById('beforeCanvas');
const afterCanvas  = document.getElementById('afterCanvas');
const brushModeBtn = document.getElementById('brushMode');
const eraseModeBtn = document.getElementById('eraseMode');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const smartBtn = document.getElementById('smartBtn');
const processBtn = document.getElementById('processBtn');
const downloadBtn = document.getElementById('downloadBtn');
const brushSizeSlider = document.getElementById('brushSize');
const brushSoftnessSlider = document.getElementById('brushSoftness');
const exportFmt = document.getElementById('exportFmt');

const bCtx = beforeCanvas.getContext('2d');
const aCtx = afterCanvas.getContext('2d');

/* ========= State ========= */
let img = new Image();
let maskCanvas = document.createElement('canvas');
let maskCtx = maskCanvas.getContext('2d');

let brushOn = false;
let eraseOn = false;
let drawing = false;
let lastPos = null;
let undoStack = [];
let redoStack = [];
const UNDO_LIMIT = 12; // memory-safe

/* ======= Helpers ======= */
uploadBox.onclick = () => fileInput.click();

fileInput.onchange = e => {
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ev => { img.onload = onImageLoad; img.src = ev.target.result; };
  reader.readAsDataURL(f);
};

function onImageLoad(){
  // set canvas sizes to image natural size
  beforeCanvas.width = afterCanvas.width = maskCanvas.width = img.naturalWidth;
  beforeCanvas.height = afterCanvas.height = maskCanvas.height = img.naturalHeight;

  // reset contexts
  maskCtx.clearRect(0,0,maskCanvas.width, maskCanvas.height);
  bCtx.clearRect(0,0,beforeCanvas.width,beforeCanvas.height);
  aCtx.clearRect(0,0,afterCanvas.width,afterCanvas.height);

  bCtx.drawImage(img,0,0);
  // keep after canvas showing original until processed
  aCtx.drawImage(img,0,0);

  undoStack = []; redoStack = [];
  lastPos = null;
}

/* ======= Coordinate mapping (handles CSS scaling) ======= */
function getCanvasPos(canvas, clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  return {x, y};
}

/* ======= Brush drawing (smooth line interpolation, soft gradient) ======= */
function beginStroke(pt){
  drawing = true;
  lastPos = pt;
  saveState();
  drawCircleOnMask(pt.x, pt.y);
}
function continueStroke(pt){
  if (!drawing) return;
  // interpolate between lastPos and pt for smoothness
  const dist = Math.hypot(pt.x - lastPos.x, pt.y - lastPos.y);
  const steps = Math.max(1, Math.ceil(dist / (brushSizeSlider.value / 3)));
  for (let i=1;i<=steps;i++){
    const t = i/steps;
    const ix = lastPos.x + (pt.x - lastPos.x) * t;
    const iy = lastPos.y + (pt.y - lastPos.y) * t;
    drawCircleOnMask(ix, iy);
  }
  lastPos = pt;
}
function endStroke(){
  drawing = false;
  lastPos = null;
}

function drawCircleOnMask(x, y){
  const size = Number(brushSizeSlider.value);
  const soft = Number(brushSoftnessSlider.value);

  // create radial gradient with alpha falloff
  const g = maskCtx.createRadialGradient(x, y, Math.max(1, size * soft), x, y, size);
  if (eraseOn) {
    // erase: draw transparent by using destination-out
    maskCtx.globalCompositeOperation = 'destination-out';
    maskCtx.fillStyle = 'rgba(0,0,0,1)';
    maskCtx.beginPath(); maskCtx.arc(x, y, size, 0, Math.PI*2); maskCtx.fill();
    maskCtx.globalCompositeOperation = 'source-over';
  } else {
    // paint alpha on mask (white center -> transparent edge). We'll draw on alpha channel via rgba white with alpha.
    // Because canvas can't directly draw only alpha channel, we'll draw white/alpha and later use alpha channel in processing.
    g.addColorStop(0, 'rgba(255,255,255,1)');
    g.addColorStop(1, 'rgba(255,255,255,0)');
    maskCtx.globalCompositeOperation = 'source-over';
    maskCtx.fillStyle = g;
    maskCtx.beginPath(); maskCtx.arc(x, y, size, 0, Math.PI*2); maskCtx.fill();
  }
  refreshOverlay();
}

/* refresh before-canvas overlay (shows mask as red tint) */
function refreshOverlay(){
  if (!img.src) return;
  bCtx.clearRect(0,0,beforeCanvas.width,beforeCanvas.height);
  bCtx.drawImage(img,0,0);
  // draw tint from mask onto before canvas
  bCtx.save();
  bCtx.globalAlpha = 0.45;
  // tint color - red-ish
  bCtx.fillStyle = 'rgba(255,64,64,0.5)';
  // draw maskCanvas using its alpha as mask: use globalCompositeOperation trick
  // create temporary canvas combining mask alpha into shape
  const tmp = document.createElement('canvas');
  tmp.width = maskCanvas.width; tmp.height = maskCanvas.height;
  const tctx = tmp.getContext('2d');
  // fill tint
  tctx.fillStyle = 'rgba(255,64,64,1)';
  tctx.fillRect(0,0,tmp.width,tmp.height);
  // set mask as alpha by using maskCanvas as destination-in
  tctx.globalCompositeOperation = 'destination-in';
  tctx.drawImage(maskCanvas,0,0);
  // draw tmp onto before canvas
  bCtx.drawImage(tmp,0,0);
  bCtx.restore();
}

/* ======= Mouse / Touch events on beforeCanvas ======= */
function attachPointerEvents(){
  // mouse
  beforeCanvas.addEventListener('mousedown', e => {
    if (!brushOn && !eraseOn) return;
    const p = getCanvasPos(beforeCanvas, e.clientX, e.clientY);
    beginStroke(p);
  });
  beforeCanvas.addEventListener('mousemove', e => {
    if (!drawing) return;
    const p = getCanvasPos(beforeCanvas, e.clientX, e.clientY);
    continueStroke(p);
  });
  window.addEventListener('mouseup', () => endStroke());

  // touch
  beforeCanvas.addEventListener('touchstart', e => {
    if (!brushOn && !eraseOn) return;
    const t = e.touches[0];
    const p = getCanvasPos(beforeCanvas, t.clientX, t.clientY);
    beginStroke(p);
    e.preventDefault();
  }, {passive:false});
  beforeCanvas.addEventListener('touchmove', e => {
    if (!drawing) return;
    const t = e.touches[0];
    const p = getCanvasPos(beforeCanvas, t.clientX, t.clientY);
    continueStroke(p);
    e.preventDefault();
  }, {passive:false});
  window.addEventListener('touchend', () => endStroke());
}
attachPointerEvents();

/* ======= Undo/Redo ======= */
function saveState(){
  try {
    const imgData = maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height);
    undoStack.push(imgData);
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    redoStack = [];
  } catch(e){ console.warn('saveState error', e); }
}
undoBtn.onclick = () => {
  if (!undoStack.length) return;
  redoStack.push(maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height));
  const prev = undoStack.pop();
  maskCtx.putImageData(prev,0,0);
  refreshOverlay();
};
redoBtn.onclick = () => {
  if (!redoStack.length) return;
  undoStack.push(maskCtx.getImageData(0,0,maskCanvas.width,maskCanvas.height));
  const next = redoStack.pop();
  maskCtx.putImageData(next,0,0);
  refreshOverlay();
};

/* ======= Brush / Erase toggles ======= */
brushModeBtn.onclick = () => {
  brushOn = !brushOn;
  if (brushOn) { eraseOn = false; eraseModeBtn.classList.remove('active'); brushModeBtn.textContent='Brush: ON'; }
  else brushModeBtn.textContent='Enable Brush';
};
eraseModeBtn.onclick = () => {
  eraseOn = !eraseOn;
  if (eraseOn) { brushOn=false; brushModeBtn.classList.remove('active'); eraseModeBtn.textContent='Erase: ON'; }
  else eraseModeBtn.textContent='Erase Mode';
};

/* ======= Smart Object Select (improved) ======= */
smartBtn.onclick = () => {
  if (!img.src) { alert('Upload image first'); return; }
  saveState();
  // parameters
  const w = maskCanvas.width, h = maskCanvas.height;
  const tctx = document.createElement('canvas').getContext('2d');
  tctx.canvas.width = w; tctx.canvas.height = h;
  tctx.drawImage(img,0,0);
  const d = tctx.getImageData(0,0,w,h).data;

  // simple brightness threshold map (0/1)
  const thresh = 180; // tuning param
  const maskMap = new Uint8Array(w*h);
  for (let i=0, p=0; i<d.length; i+=4, p++){
    const r=d[i], g=d[i+1], b=d[i+2];
    const brightness = (0.299*r + 0.587*g + 0.114*b);
    maskMap[p] = (brightness > thresh) ? 1 : 0;
  }

  // connected components to find largest blob (helps avoid whole-image)
  const visited = new Uint8Array(w*h);
  let largestLabel = -1, largestSize = 0;
  const dirs = [-1,1,-w,w];

  for (let idx=0; idx<w*h; idx++){
    if (visited[idx] || !maskMap[idx]) continue;
    // BFS
    let q=[idx]; visited[idx]=1; let qhead=0; let size=0;
    while(qhead<q.length){
      const cur = q[qhead++]; size++;
      // neighbors: 4-connectivity
      const x = cur % w;
      const y = Math.floor(cur / w);
      const n1 = cur-1, n2 = cur+1, n3 = cur-w, n4 = cur+w;
      if (x>0 && !visited[n1] && maskMap[n1]){ visited[n1]=1; q.push(n1); }
      if (x<w-1 && !visited[n2] && maskMap[n2]){ visited[n2]=1; q.push(n2); }
      if (y>0 && !visited[n3] && maskMap[n3]){ visited[n3]=1; q.push(n3); }
      if (y<h-1 && !visited[n4] && maskMap[n4]){ visited[n4]=1; q.push(n4); }
    }
    if (size > largestSize){ largestSize = size; largestLabel = idx; }
  }

  // if no largest found, fallback: select center region
  if (largestSize === 0){
    // fallback: center flood from center pixel if bright
    const cx = Math.floor(w/2), cy = Math.floor(h/2);
    const cidx = cy*w + cx;
    if (maskMap[cidx]) largestLabel = cidx;
  }

  // if still none, just select all bright pixels
  // build final mask: if pixel connected to largestLabel mark =1
  const finalMask = new Uint8Array(w*h);
  if (largestLabel !== -1){
    // BFS from largestLabel (but we need the component we found earlier; we didn't store labels.
    // Simpler: re-run BFS starting at largestLabel using maskMap)
    const q=[largestLabel]; const mark = new Uint8Array(w*h); mark[largestLabel]=1;
    let qh=0;
    while(qh<q.length){
      const cur = q[qh++]; finalMask[cur]=1;
      const x = cur % w;
      const y = Math.floor(cur / w);
      const n1 = cur-1, n2=cur+1, n3=cur-w, n4=cur+w;
      if (x>0 && !mark[n1] && maskMap[n1]){ mark[n1]=1; q.push(n1); }
      if (x<w-1 && !mark[n2] && maskMap[n2]){ mark[n2]=1; q.push(n2); }
      if (y>0 && !mark[n3] && maskMap[n3]){ mark[n3]=1; q.push(n3); }
      if (y<h-1 && !mark[n4] && maskMap[n4]){ mark[n4]=1; q.push(n4); }
    }
  } else {
    // fallback: mark all bright pixels
    for (let i=0;i<w*h;i++) finalMask[i] = maskMap[i];
  }

  // write finalMask into maskCanvas (as white areas)
  const mm = maskCtx.createImageData(w,h);
  for (let p=0, i=0; p<w*h; p++, i+=4){
    if (finalMask[p]){
      mm.data[i] = 255; mm.data[i+1] = 255; mm.data[i+2] = 255; mm.data[i+3] = 255;
    } else { mm.data[i+3] = 0; }
  }
  maskCtx.putImageData(mm, 0, 0);
  refreshOverlay();
};

/* ======= Processing: apply mask to image and refine edges ======= */
function boxBlurAlpha(data, w, h, radius){
  // simple separable box blur on alpha channel
  const tmp = new Uint8ClampedArray(data.length);
  tmp.set(data);
  const out = new Uint8ClampedArray(data.length);
  // horizontal
  const rr = radius;
  for (let y=0;y<h;y++){
    let sum=0, count=0;
    for (let x=0;x<w;x++){
      const i = (y*w + x)*4 + 3;
      // accumulate for first window
    }
    // horizontal pass (optimized simple)
  }
  // Instead of heavy blur, we'll use Canvas filter to blur mask quickly (draw to temp canvas and use ctx.filter)
  return data;
}

processBtn.onclick = () => {
  if (!img.src) { alert('Upload image first'); return; }
  const w = afterCanvas.width, h = afterCanvas.height;

  // copy original image into a temp canvas
  const temp = document.createElement('canvas');
  temp.width = w; temp.height = h;
  const tctx = temp.getContext('2d');
  tctx.drawImage(img,0,0);

  // get image and mask
  const imgData = tctx.getImageData(0,0,w,h);
  const maskData = maskCtx.getImageData(0,0,w,h);

  // optional: quick edge refine using lightweight blur by drawing mask into temp canvas with CSS filter
  // create small temp canvas and use ctx.filter blur, then read back alpha
  const mtmp = document.createElement('canvas');
  mtmp.width = w; mtmp.height = h;
  const mctx = mtmp.getContext('2d');
  // draw mask onto mctx
  mctx.putImageData(maskData,0,0);
  // apply a blur by using globalComposite and shadow trick (browser dependent) â€” simpler: draw scaled down/up to blur
  const scale = 0.25;
  const smallW = Math.max(1, Math.floor(w*scale));
  const smallH = Math.max(1, Math.floor(h*scale));
  const small = document.createElement('canvas'); small.width = smallW; small.height = smallH;
  const sctx = small.getContext('2d');
  sctx.drawImage(mtmp, 0, 0, smallW, smallH);
  mctx.clearRect(0,0,w,h);
  mctx.drawImage(small, 0, 0, smallW, smallH, 0, 0, w, h);
  const refined = mctx.getImageData(0,0,w,h);

  // apply mask alpha to original image: if refined.alpha < threshold -> make transparent
  const out = tctx.getImageData(0,0,w,h);
  for (let i=0;i<out.data.length;i+=4){
    const a = refined.data[i+3]; // alpha 0..255
    if (a < 80) out.data[i+3] = 0;
  }
  // put to after canvas
  aCtx.putImageData(out,0,0);
};

/* ======= Download ======= */
downloadBtn.onclick = () => {
  const fmt = exportFmt.value;
  let dataUrl;
  if (fmt === 'jpg') dataUrl = afterCanvas.toDataURL('image/jpeg', 0.92);
  else if (fmt === 'webp') dataUrl = afterCanvas.toDataURL('image/webp', 0.92);
  else dataUrl = afterCanvas.toDataURL('image/png');

  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = 'output.' + (fmt==='png'?'png':(fmt==='jpg'?'jpg':'webp'));
  a.click();
};

/* ======= Init: attach events and small safeguards ======= */
attachPointerEvents();
window.addEventListener('resize', () => { /* no-op for now */ });

</script>
</body>
</html>
